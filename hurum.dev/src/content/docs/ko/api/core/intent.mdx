---
title: Intent
description: "Intent, Intents, 실행 모드의 API 레퍼런스예요."
---

```ts
import { Intent, Intents } from '@hurum/core'
```

## `Intent(...steps)`

순차적 Intent를 생성해요. step이 순서대로 실행돼요. step 중 하나가 예외를 던지면 이후 step은 건너뛰어요.

각 step은 `Command` 또는 `EventCreator`일 수 있어요. Command step은 등록된 Executor로 디스패치돼요. EventCreator step은 Event를 직접 emit해요 — Executor 등록이 필요 없어요.

### 시그니처

```ts
function Intent<TInput>(...steps: IntentStep<TInput>[]): IntentAction<TInput>
```

### 매개변수

| 매개변수 | 타입 | 설명 |
|-----------|------|-------------|
| `...steps` | `IntentStep<TInput>[]` | 순서대로 실행할 하나 이상의 step (Command 또는 EventCreator). |

### 반환값

`IntentAction<TInput>` -- Intent 디스크립터이자 호출 가능한 함수예요.

### 예제

```ts
const PurchaseIntents = Intents('Purchase', {
  // Command steps — Executor 실행
  submitClicked: Intent(ValidateCmd, SaveCmd),
  pageOpened: Intent(LoadCmd),

  // EventCreator step — 직접 emit, Executor 불필요
  cancelled: Intent(PurchaseEvent.cancelled),
})
```

---

## `Intent.all(...steps)`

병렬, fail-fast Intent를 생성해요. 모든 step이 동시에 시작돼요. 하나가 실패하면 나머지는 `AbortSignal`로 중단돼요.

### 시그니처

```ts
Intent.all<TInput>(...steps: IntentStep<TInput>[]): IntentAction<TInput>
```

### 예제

```ts
const DashboardIntents = Intents('Dashboard', {
  pageOpened: Intent.all(LoadUserCmd, LoadStatsCmd, LoadNotificationsCmd),
})
```

---

## `Intent.allSettled(...steps)`

병렬, 독립적 Intent를 생성해요. 모든 step이 동시에 시작돼요. 각각 독립적으로 완료까지 실행되며 -- 하나의 실패가 다른 것에 영향을 주지 않아요.

### 시그니처

```ts
Intent.allSettled<TInput>(...steps: IntentStep<TInput>[]): IntentAction<TInput>
```

### 예제

```ts
const SyncIntents = Intents('Sync', {
  syncAll: Intent.allSettled(SyncContactsCmd, SyncCalendarCmd, SyncFilesCmd),
})
```

---

## `Intents(prefix, definitions)`

네임스페이스가 지정된 Intent 컨테이너를 생성해요. 컨테이너는 `Store.intents()`에 전달해서 Store에 Intent 액션을 등록해요.

### 시그니처

```ts
function Intents<TPrefix extends string, TDefs extends Record<string, IntentDescriptor>>(
  prefix: TPrefix,
  intents: TDefs,
): TDefs & IntentsContainer
```

### 매개변수

| 매개변수 | 타입 | 설명 |
|-----------|------|-------------|
| `prefix` | `string` | 식별을 위한 네임스페이스 접두사. |
| `intents` | `Record<string, IntentDescriptor>` | Intent 이름에서 `Intent(...)` 정의로의 맵. |

### 반환값

`intents`와 동일한 키를 가진 `IntentsContainer`. 각 값은 `IntentAction`이에요.

### 예제

```ts
const CartIntents = Intents('Cart', {
  addItem: Intent(AddItemCmd),
  checkout: Intent(ValidateCartCmd, ProcessPaymentCmd, ConfirmOrderCmd),
  refreshPrices: Intent.all(FetchPriceCmd, FetchTaxCmd),
})
```

---

## `IntentStep<TInput>`

Intent가 실행할 수 있는 step의 유니온 타입이에요:

```ts
type IntentStep<TInput> = Command<TInput> | EventCreator<string, TInput>
```

- **`Command<TInput>`** — 등록된 Executor로 디스패치돼요. Executor는 비동기 로직을 실행하고, deps에 접근하며, Event를 emit해요.
- **`EventCreator<string, TInput>`** — Event로 직접 emit돼요. Executor가 필요 없어요. 페이로드를 Event에 단순 매핑하는 상태 전환에 사용하세요.

---

## `IntentAction<TInput>`

`Intent(...)`가 생성하는 각 Intent의 타입이에요. `IntentDescriptor`이면서 호출 가능한 함수예요.

### 속성

| 속성 | 타입 | 설명 |
|----------|------|-------------|
| `steps` | `ReadonlyArray<IntentStep<TInput>>` | 이 Intent가 실행할 step (Command 또는 EventCreator) 목록. |
| `mode` | `'sequential' \| 'all' \| 'allSettled'` | 실행 전략. |

### 호출 시그니처

```ts
(payload: TInput) => PreparedIntent<TInput>
```

`IntentAction`에 페이로드를 전달해서 호출하면 `store.send()`에 전달할 수 있는 `PreparedIntent`가 생성돼요.

### 예제

```ts
// Create a PreparedIntent
const prepared = CartIntents.addItem({ item: newItem })

// Send it
store.send(prepared)

// Or use the shorthand (equivalent)
store.send.addItem({ item: newItem })
```

---

## `PreparedIntent<TInput>`

페이로드와 쌍을 이루어 디스패치 준비가 된 Intent예요. `IntentAction`에 페이로드를 전달해서 호출하면 생성돼요.

### 속성

| 속성 | 타입 | 설명 |
|----------|------|-------------|
| `intent` | `IntentDescriptor<TInput>` | 원본 Intent 디스크립터. |
| `payload` | `TInput` | 각 step에 전달할 페이로드. |

---

## `IntentRef`

`store.send()`가 반환하는 불투명 참조예요. 취소에 사용돼요.

```ts
const ref = store.send.submitClicked({ formData })

// Cancel this specific intent
store.cancel(ref)
```

---

## 실행 모드 요약

| 모드 | 함수 | 실패 시 동작 |
|------|----------|---------------------|
| 순차 | `Intent(A, B, C)` | 실패한 step에서 중단. B와 C는 건너뛰어요. |
| 병렬 fail-fast | `Intent.all(A, B, C)` | `AbortSignal`로 나머지를 모두 중단해요. |
| 병렬 독립 | `Intent.allSettled(A, B, C)` | 다른 step은 계속 실행돼요. 오류는 middleware로 보고돼요. |

---

## 참고사항

- Intent는 사용자 액션이나 시스템 트리거를 나타내요 ("submit clicked", "page opened"). 사용자의 관점에서 이름을 지정하세요.
- 페이로드 타입 `TInput`은 Intent의 모든 step이 공유해요. 체인의 모든 Executor 또는 EventCreator가 동일한 페이로드를 받아요.
- 기본적으로 `Intent()` (순차)를 사용하세요. 병렬 실행이 필요한 경우에만 `Intent.all()` 또는 `Intent.allSettled()`로 전환하세요.
- Event만 emit하는 단순한 상태 전환에는 `EventCreator`를 `Intent()`에 직접 전달하세요 -- `CommandExecutor`가 필요 없어요.
